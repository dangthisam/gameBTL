import socket
import pickle
import threading
import pygame
from pygame import mixer
import sys
import time

from fighter import Fighter

class GameClient:
    def __init__(self, host='localhost', port=5555):
        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server = host
        self.port = port
        self.addr = (self.server, self.port)
        self.player_id = None
        self.game_state = None
        self.running = True
        self.connection_established = False
        self.connection_error = None
        self.connection_retry_count = 0
        self.max_retries = 3
        
        # Initialize pygame and mixer
        mixer.init()
        pygame.init()
        
        # Game window setup
        self.SCREEN_WIDTH = 1000
        self.SCREEN_HEIGHT = 600
        self.screen = pygame.display.set_mode((self.SCREEN_WIDTH, self.SCREEN_HEIGHT))
        pygame.display.set_caption("Brawler Game - Network Edition")
        self.clock = pygame.time.Clock()
        self.FPS = 60
        
        # Colors
        self.RED = (255, 0, 0)
        self.YELLOW = (255, 255, 0)
        self.WHITE = (255, 255, 255)
        self.BLUE = (0, 0, 255)
        self.BLACK = (0, 0, 0)
        self.GREEN = (0, 255, 0)
        
        # Game variables
        self.intro_count = 5
        self.last_count_update = pygame.time.get_ticks()
        self.round_over = False
        self.ROUND_OVER_COOLDOWN = 2000
        self.game_over = False
        self.WIN_SCORE = 5
        self.winner = 0
        self.show_controls = True
        self.local_player_control = True  # Flag to ensure player controls are responsive
        
        # Fighter variables
        self.WARRIOR_SIZE = 162
        self.WARRIOR_SCALE = 4
        self.WARRIOR_OFFSET = [72, 56]
        self.WARRIOR_DATA = [self.WARRIOR_SIZE, self.WARRIOR_SCALE, self.WARRIOR_OFFSET]
        self.WIZARD_SIZE = 250
        self.WIZARD_SCALE = 3
        self.WIZARD_OFFSET = [112, 107]
        self.WIZARD_DATA = [self.WIZARD_SIZE, self.WIZARD_SCALE, self.WIZARD_OFFSET]
        
        # Load resources
        self.load_resources()
        
        # Create fighters
        self.fighter_1 = Fighter(1, 200, 310, False, self.WARRIOR_DATA, self.warrior_sheet, 
                                [10, 8, 1, 7, 7, 3, 7], self.sword_fx)
        self.fighter_2 = Fighter(2, 700, 310, True, self.WIZARD_DATA, self.wizard_sheet, 
                                [8, 8, 1, 8, 8, 3, 7], self.magic_fx)
        
        # Network update rate (to prevent flooding the server)
        self.last_update_time = 0
        self.update_interval = 1000 / 30  # 30 updates per second
        self.debug_mode = False  # Toggle for debug information
        
    def load_resources(self):
        """Load game resources"""
        try:
            # Load music and sounds
            pygame.mixer.music.load("assets/audio/ok.mp3")
            pygame.mixer.music.set_volume(1)
            pygame.mixer.music.play(-1, 0.0, 5000)
            self.sword_fx = pygame.mixer.Sound("assets/audio/sword.wav")
            self.sword_fx.set_volume(0.5)
            self.magic_fx = pygame.mixer.Sound("assets/audio/magic.wav")
            self.magic_fx.set_volume(0.75)
            
            # Load background image
            self.bg_image = pygame.image.load("assets/images/background/background.jpg").convert_alpha()
            
            # Load spritesheets
            self.warrior_sheet = pygame.image.load("assets/images/warrior/Sprites/warrior.png").convert_alpha()
            self.wizard_sheet = pygame.image.load("assets/images/wizard/Sprites/wizard.png").convert_alpha()
            
            # Load victory image
            self.victory_img = pygame.image.load("assets/images/icons/victory.png").convert_alpha()
            
            # Define fonts
            self.count_font = pygame.font.Font("assets/fonts/turok.ttf", 80)
            self.score_font = pygame.font.Font("assets/fonts/turok.ttf", 30)
            self.game_over_font = pygame.font.Font("assets/fonts/turok.ttf", 50)
            self.controls_font = pygame.font.Font("assets/fonts/turok.ttf", 25)
            self.title_font = pygame.font.Font("assets/fonts/turok.ttf", 40)
            self.debug_font = pygame.font.Font("assets/fonts/turok.ttf", 16)
        except Exception as e:
            print(f"Error loading resources: {e}")
            pygame.quit()
            sys.exit()
    
    def connect(self):
        """Connect to the server with retry mechanism"""
        while self.connection_retry_count < self.max_retries and not self.connection_established:
            try:
                print(f"Attempting to connect to server at {self.addr} (Attempt {self.connection_retry_count + 1}/{self.max_retries})")
                
                # Set socket timeout for connection
                self.client.settimeout(5)
                self.client.connect(self.addr)
                
                # Reset timeout to None (blocking mode) for normal operation
                self.client.settimeout(None)
                
                print(f"Connected to server at {self.addr}")
                
                # Receive player ID from server
                data = self.client.recv(4096)
                if not data:
                    raise Exception("No data received from server")
                    
                response = pickle.loads(data)
                
                if "error" in response:
                    raise Exception(f"Server error: {response['error']}")
                
                self.player_id = response["player_id"]
                print(f"You are {self.player_id}")
                
                # Send initial confirmation to server
                self.send_data({"player_id": self.player_id, "status": "connected"})
                
                # Start receiving data from server
                self.connection_established = True
                receive_thread = threading.Thread(target=self.receive_data)
                receive_thread.daemon = True
                receive_thread.start()
                
                # Connection successful
                return True
                
            except Exception as e:
                self.connection_error = str(e)
                print(f"Connection error: {e}")
                self.connection_retry_count += 1
                
                # Close socket and create a new one for retry
                try:
                    self.client.close()
                except:
                    pass
                    
                self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                time.sleep(1)
        
        # If we've exhausted our retries
        if not self.connection_established:
            print("Failed to connect to server after multiple attempts")
            return False
    
    def receive_data(self):
        """Continuously receive data from server"""
        self.client.settimeout(5)  # Set timeout to detect disconnection
        
        while self.running:
            try:
                data = self.client.recv(4096)
                if not data:
                    print("Server disconnected (no data)")
                    break
                    
                self.game_state = pickle.loads(data)
                
                # Debug: Print entire game state occasionally
                if self.debug_mode:
                    print(f"Received game state: {self.game_state}")
                
                # Update local game state based on server data
                if self.game_state and "game_active" in self.game_state:
                    # Handle round reset signal from server
                    if "round_reset" in self.game_state and self.game_state["round_reset"]:
                        print("Received round reset signal - resetting local player state")
                        self.reset_player_state()
                    
                    # Update game state variables
                    self.round_over = self.game_state["round_over"]
                    self.game_over = self.game_state["game_over"]
                    self.winner = self.game_state["winner"]
                    self.intro_count = self.game_state["intro_count"]
                    
                    if self.game_state["game_active"]:
                        # Update fighter states based on player role
                        if self.player_id == "player1":
                            # For player1: Update health, hit state, and position if necessary
                            self.fighter_1.health = self.game_state["player1"]["health"]
                            self.fighter_1.hit = self.game_state["player1"]["hit"]
                            
                            # Reset position if needed (e.g., at round start)
                            if self.intro_count > 0:
                                self.fighter_1.rect.x = self.game_state["player1"]["x"]
                                self.fighter_1.rect.y = self.game_state["player1"]["y"]
                            
                            # Update entire state of opponent
                            if "player2" in self.game_state:
                                self.fighter_2.rect.x = self.game_state["player2"]["x"]
                                self.fighter_2.rect.y = self.game_state["player2"]["y"]
                                self.fighter_2.health = self.game_state["player2"]["health"]
                                self.fighter_2.action = self.game_state["player2"]["action"]
                                self.fighter_2.frame_index = self.game_state["player2"]["frame_index"]
                                self.fighter_2.flip = self.game_state["player2"]["flip"]
                                self.fighter_2.attacking = self.game_state["player2"]["attacking"]
                                self.fighter_2.hit = self.game_state["player2"]["hit"]
                                
                        elif self.player_id == "player2":
                            # For player2: Update health, hit state, and position if necessary
                            self.fighter_2.health = self.game_state["player2"]["health"]
                            self.fighter_2.hit = self.game_state["player2"]["hit"]
                            
                            # Reset position if needed (e.g., at round start)
                            if self.intro_count > 0:
                                self.fighter_2.rect.x = self.game_state["player2"]["x"]
                                self.fighter_2.rect.y = self.game_state["player2"]["y"]
                            
                            # Update entire state of opponent
                            if "player1" in self.game_state:
                                self.fighter_1.rect.x = self.game_state["player1"]["x"]
                                self.fighter_1.rect.y = self.game_state["player1"]["y"]
                                self.fighter_1.health = self.game_state["player1"]["health"]
                                self.fighter_1.action = self.game_state["player1"]["action"]
                                self.fighter_1.frame_index = self.game_state["player1"]["frame_index"]
                                self.fighter_1.flip = self.game_state["player1"]["flip"]
                                self.fighter_1.attacking = self.game_state["player1"]["attacking"]
                                self.fighter_1.hit = self.game_state["player1"]["hit"]
                
            except socket.timeout:
                # Just retry on timeout
                continue
            except ConnectionResetError:
                print("Connection reset by server")
                break
            except ConnectionAbortedError:
                print("Connection aborted")
                break
            except Exception as e:
                print(f"Error receiving data: {e}")
                break
                
        print("Disconnected from server")
        self.connection_established = False
        self.running = False
    
    def reset_player_state(self):
        """Reset player state at the beginning of a new round"""
        if self.player_id == "player1":
            self.fighter_1.rect.x = 200
            self.fighter_1.rect.y = 310
            self.fighter_1.health = 100
            self.fighter_1.attacking = False
            self.fighter_1.hit = False
            self.fighter_1.action = 0
            self.fighter_1.jump = False
            self.fighter_1.jumping = False
            self.fighter_1.attack_type = 0
        elif self.player_id == "player2":
            self.fighter_2.rect.x = 700
            self.fighter_2.rect.y = 310
            self.fighter_2.health = 100
            self.fighter_2.attacking = False
            self.fighter_2.hit = False
            self.fighter_2.action = 0
            self.fighter_2.jump = False
            self.fighter_2.jumping = False
            self.fighter_2.attack_type = 0
        
    def send_data(self, data):
        """Send data to server with error handling"""
        if not self.connection_established:
            return
            
        try:
            serialized_data = pickle.dumps(data)
            self.client.send(serialized_data)
            if self.debug_mode and "player_id" in data:
                print(f"Sent data: {data}")
        except ConnectionResetError:
            print("Connection reset by server while sending data")
            self.connection_established = False
            self.running = False
        except Exception as e:
            print(f"Error sending data: {e}")
            self.connection_established = False
            self.running = False
    
    def draw_text(self, text, font, text_col, x, y):
        """Draw text on screen"""
        img = font.render(text, True, text_col)
        text_rect = img.get_rect(center=(x, y))
        self.screen.blit(img, text_rect)
    
    def draw_left_aligned_text(self, text, font, text_col, x, y):
        """Draw left-aligned text"""
        img = font.render(text, True, text_col)
        self.